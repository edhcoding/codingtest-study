// 실패율 = (스테이지에 머물러 있는 사용자 수) / (스테이지에 도달한 전체 사용자 수)
// 스테이지에 도달한 유저가 없으면 실패율은 0
// 실패율을 내림차순으로 정렬
// 실패율이 같은 경우 스테이지 번호 오름차순으로 정렬

function solution(N, stages) {
  var result = [];

  // 1부터 N까지의 스테이지 각각에 대해
  for (let i = 1; i <= N; i++) {
    // 현재 스테이지에 머물러 있는 사람의 수
    let 도전중인사람 = stages.filter((x) => x === i).length;
    // 현재 스테이지에 도달한 사람의 수
    let 도달한사람 = stages.filter((x) => x >= i).length;

    // 실패율 계산하고 스테이지 번호와 함께 저장
    result.push({
      스테이지: i,
      실패율: 도달한사람 === 0 ? 0 : 도전중인사람 / 도달한사람,
    });
  }

  return result
    .sort((a, b) => b.실패율 - a.실패율) // 실패율 높은순서대로 정렬 (내림차순)
    .map((x) => x.스테이지); // 정렬된 객체 배열에서 스테이지 번호만 뽑아내기 위해서!
}

/*
 * 시간 복잡도: O(N * S)
 * - N은 스테이지 수, S는 stages 배열의 길이입니다.
 *
 * 각 단계별 분석:
 * 1. 외부 for 루프: O(N)
 * 2. 각 루프 내부:
 *    - filter() 두 번 실행: O(S) + O(S)
 * 3. sort(): O(N log N)
 * - Timsort 알고리즘은 O(n)이 되는 경우도 있지만 여기서는 아님
 * 4. map(): O(N)
 * 따라서 총 시간 복잡도는 O(N * S)가 됩니다.
 *
 * 공간 복잡도: O(N)
 * - (변수) result 배열: O(N)
 * - 정렬과 map에서 생성되는 임시 배열: O(N)
 * - 그 외 변수들: O(1)
 */
